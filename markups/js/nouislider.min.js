/*! nouislider - 13.1.4 - 3/20/2019 */
!(function (t) { typeof define === 'function' && define.amd ? define([], t) : typeof exports === 'object' ? module.exports = t() : window.noUiSlider = t(); }(() => {
	const ut = '13.1.4'; function ct(t) { t.parentElement.removeChild(t); } function s(t) { return t != null; } function pt(t) { t.preventDefault(); } function i(t) { return typeof t === 'number' && !isNaN(t) && isFinite(t); } function ft(t, e, r) { r > 0 && (mt(t, e), setTimeout(() => { gt(t, e); }, r)); } function dt(t) { return Math.max(Math.min(t, 100), 0); } function ht(t) { return Array.isArray(t) ? t : [t]; } function e(t) { const e = (t = String(t)).split('.'); return e.length > 1 ? e[1].length : 0; } function mt(t, e) { t.classList ? t.classList.add(e) : t.className += ' ' + e; } function gt(t, e) { t.classList ? t.classList.remove(e) : t.className = t.className.replace(new RegExp('(^|\\b)' + e.split(' ').join('|') + '(\\b|$)', 'gi'), ' '); } function vt(t) { const e = void 0 !== window.pageXOffset; const r = (t.compatMode || '') === 'CSS1Compat'; return { x: e ? window.pageXOffset : r ? t.documentElement.scrollLeft : t.body.scrollLeft, y: e ? window.pageYOffset : r ? t.documentElement.scrollTop : t.body.scrollTop }; } function c(t, e) { return 100 / (e - t); } function p(t, e) { return 100 * e / (t[1] - t[0]); } function f(t, e) { for (var r = 1; t >= e[r];)r += 1; return r; } function r(t, e, r) { if (r >= t.slice(-1)[0]) return 100; let n; let i; const o = f(r, t); const a = t[o - 1]; const s = t[o]; const l = e[o - 1]; const u = e[o]; return l + (i = r, p(n = [a, s], n[0] < 0 ? i + Math.abs(n[0]) : i - n[0]) / c(l, u)); } function n(t, e, r, n) { if (n === 100) return n; let i; let o; const a = f(n, t); const s = t[a - 1]; const l = t[a]; return r ? (l - s) / 2 < n - s ? l : s : e[a - 1] ? t[a - 1] + (i = n - t[a - 1], o = e[a - 1], Math.round(i / o) * o) : n; } function o(t, e, r) { let n; if (typeof e === 'number' && (e = [e]), !Array.isArray(e)) throw new Error('noUiSlider (' + ut + '): \'range\' contains invalid value.'); if (!i(n = t === 'min' ? 0 : t === 'max' ? 100 : parseFloat(t)) || !i(e[0])) throw new Error('noUiSlider (' + ut + '): \'range\' value isn\'t numeric.'); r.xPct.push(n), r.xVal.push(e[0]), n ? r.xSteps.push(!isNaN(e[1]) && e[1]) : isNaN(e[1]) || (r.xSteps[0] = e[1]), r.xHighestCompleteStep.push(0); } function a(t, e, r) { if (e) if (r.xVal[t] !== r.xVal[t + 1]) { r.xSteps[t] = p([r.xVal[t], r.xVal[t + 1]], e) / c(r.xPct[t], r.xPct[t + 1]); const n = (r.xVal[t + 1] - r.xVal[t]) / r.xNumSteps[t]; const i = Math.ceil(Number(n.toFixed(3)) - 1); const o = r.xVal[t] + r.xNumSteps[t] * i; r.xHighestCompleteStep[t] = o; } else r.xSteps[t] = r.xHighestCompleteStep[t] = r.xVal[t]; } function l(t, e, r) { let n; this.xPct = [], this.xVal = [], this.xSteps = [r || !1], this.xNumSteps = [!1], this.xHighestCompleteStep = [], this.snap = e; const i = []; for (n in t)t.hasOwnProperty(n) && i.push([t[n], n]); for (i.length && typeof i[0][0] === 'object' ? i.sort((t, e) => { return t[0][0] - e[0][0]; }) : i.sort((t, e) => { return t[0] - e[0]; }), n = 0; n < i.length; n++)o(i[n][1], i[n][0], this); for (this.xNumSteps = this.xSteps.slice(0), n = 0; n < this.xNumSteps.length; n++)a(n, this.xNumSteps[n], this); }l.prototype.getMargin = function (t) { const e = this.xNumSteps[0]; if (e && t / e % 1 != 0) throw new Error('noUiSlider (' + ut + '): \'limit\', \'margin\' and \'padding\' must be divisible by step.'); return this.xPct.length === 2 && p(this.xVal, t); }, l.prototype.toStepping = function (t) { return t = r(this.xVal, this.xPct, t); }, l.prototype.fromStepping = function (t) { return (function (t, e, r) { if (r >= 100) return t.slice(-1)[0]; let n; const i = f(r, e); const o = t[i - 1]; const a = t[i]; const s = e[i - 1]; const l = e[i]; return n = [o, a], (r - s) * c(s, l) * (n[1] - n[0]) / 100 + n[0]; }(this.xVal, this.xPct, t)); }, l.prototype.getStep = function (t) { return t = n(this.xPct, this.xSteps, this.snap, t); }, l.prototype.getDefaultStep = function (t, e, r) { let n = f(t, this.xPct); return (t === 100 || e && t === this.xPct[n - 1]) && (n = Math.max(n - 1, 1)), (this.xVal[n] - this.xVal[n - 1]) / r; }, l.prototype.getNearbySteps = function (t) { const e = f(t, this.xPct); return { stepBefore: { startValue: this.xVal[e - 2], step: this.xNumSteps[e - 2], highestStep: this.xHighestCompleteStep[e - 2] }, thisStep: { startValue: this.xVal[e - 1], step: this.xNumSteps[e - 1], highestStep: this.xHighestCompleteStep[e - 1] }, stepAfter: { startValue: this.xVal[e], step: this.xNumSteps[e], highestStep: this.xHighestCompleteStep[e] } }; }, l.prototype.countStepDecimals = function () { const t = this.xNumSteps.map(e); return Math.max.apply(null, t); }, l.prototype.convert = function (t) { return this.getStep(this.toStepping(t)); }; const u = { to(t) { return void 0 !== t && t.toFixed(2); }, from: Number }; function d(t) { if (typeof (e = t) === 'object' && typeof e.to === 'function' && typeof e.from === 'function') return !0; let e; throw new Error('noUiSlider (' + ut + '): \'format\' requires \'to\' and \'from\' methods.'); } function h(t, e) { if (!i(e)) throw new Error('noUiSlider (' + ut + '): \'step\' is not numeric.'); t.singleStep = e; } function m(t, e) { if (typeof e !== 'object' || Array.isArray(e)) throw new Error('noUiSlider (' + ut + '): \'range\' is not an object.'); if (void 0 === e.min || void 0 === e.max) throw new Error('noUiSlider (' + ut + '): Missing \'min\' or \'max\' in \'range\'.'); if (e.min === e.max) throw new Error('noUiSlider (' + ut + '): \'range\' \'min\' and \'max\' cannot be equal.'); t.spectrum = new l(e, t.snap, t.singleStep); } function g(t, e) { if (e = ht(e), !Array.isArray(e) || !e.length) throw new Error('noUiSlider (' + ut + '): \'start\' option is incorrect.'); t.handles = e.length, t.start = e; } function v(t, e) { if (typeof (t.snap = e) !== 'boolean') throw new Error('noUiSlider (' + ut + '): \'snap\' option must be a boolean.'); } function b(t, e) { if (typeof (t.animate = e) !== 'boolean') throw new Error('noUiSlider (' + ut + '): \'animate\' option must be a boolean.'); } function S(t, e) { if (typeof (t.animationDuration = e) !== 'number') throw new Error('noUiSlider (' + ut + '): \'animationDuration\' option must be a number.'); } function x(t, e) { let r; let n = [!1]; if (e === 'lower' ? e = [!0, !1] : e === 'upper' && (e = [!1, !0]), !0 === e || !1 === e) { for (r = 1; r < t.handles; r++)n.push(e); n.push(!1); } else { if (!Array.isArray(e) || !e.length || e.length !== t.handles + 1) throw new Error('noUiSlider (' + ut + '): \'connect\' option doesn\'t match handle count.'); n = e; }t.connect = n; } function w(t, e) { switch (e) { case 'horizontal': t.ort = 0; break; case 'vertical': t.ort = 1; break; default: throw new Error('noUiSlider (' + ut + '): \'orientation\' option is invalid.'); } } function y(t, e) { if (!i(e)) throw new Error('noUiSlider (' + ut + '): \'margin\' option must be numeric.'); if (e !== 0 && (t.margin = t.spectrum.getMargin(e), !t.margin)) throw new Error('noUiSlider (' + ut + '): \'margin\' option is only supported on linear sliders.'); } function E(t, e) { if (!i(e)) throw new Error('noUiSlider (' + ut + '): \'limit\' option must be numeric.'); if (t.limit = t.spectrum.getMargin(e), !t.limit || t.handles < 2) throw new Error('noUiSlider (' + ut + '): \'limit\' option is only supported on linear sliders with 2 or more handles.'); } function C(t, e) { if (!i(e) && !Array.isArray(e)) throw new Error('noUiSlider (' + ut + '): \'padding\' option must be numeric or array of exactly 2 numbers.'); if (Array.isArray(e) && e.length !== 2 && !i(e[0]) && !i(e[1])) throw new Error('noUiSlider (' + ut + '): \'padding\' option must be numeric or array of exactly 2 numbers.'); if (e !== 0) { if (Array.isArray(e) || (e = [e, e]), !(t.padding = [t.spectrum.getMargin(e[0]), t.spectrum.getMargin(e[1])]) === t.padding[0] || !1 === t.padding[1]) throw new Error('noUiSlider (' + ut + '): \'padding\' option is only supported on linear sliders.'); if (t.padding[0] < 0 || t.padding[1] < 0) throw new Error('noUiSlider (' + ut + '): \'padding\' option must be a positive number(s).'); if (t.padding[0] + t.padding[1] >= 100) throw new Error('noUiSlider (' + ut + '): \'padding\' option must not exceed 100% of the range.'); } } function N(t, e) { switch (e) { case 'ltr': t.dir = 0; break; case 'rtl': t.dir = 1; break; default: throw new Error('noUiSlider (' + ut + '): \'direction\' option was not recognized.'); } } function U(t, e) { if (typeof e !== 'string') throw new Error('noUiSlider (' + ut + '): \'behaviour\' must be a string containing options.'); const r = e.indexOf('tap') >= 0; const n = e.indexOf('drag') >= 0; const i = e.indexOf('fixed') >= 0; const o = e.indexOf('snap') >= 0; const a = e.indexOf('hover') >= 0; const s = e.indexOf('unconstrained') >= 0; if (i) { if (t.handles !== 2) throw new Error('noUiSlider (' + ut + '): \'fixed\' behaviour must be used with 2 handles'); y(t, t.start[1] - t.start[0]); } if (s && (t.margin || t.limit)) throw new Error('noUiSlider (' + ut + '): \'unconstrained\' behaviour cannot be used with margin or limit'); t.events = { tap: r || o, drag: n, fixed: i, snap: o, hover: a, unconstrained: s }; } function k(t, e) { if (!1 !== e) if (!0 === e) { t.tooltips = []; for (let r = 0; r < t.handles; r++)t.tooltips.push(!0); } else { if (t.tooltips = ht(e), t.tooltips.length !== t.handles) throw new Error('noUiSlider (' + ut + '): must pass a formatter for all handles.'); t.tooltips.forEach((t) => { if (typeof t !== 'boolean' && (typeof t !== 'object' || typeof t.to !== 'function')) throw new Error('noUiSlider (' + ut + '): \'tooltips\' must be passed a formatter or \'false\'.'); }); } } function P(t, e) { d(t.ariaFormat = e); } function A(t, e) { d(t.format = e); } function V(t, e) { if (typeof (t.keyboardSupport = e) !== 'boolean') throw new Error('noUiSlider (' + ut + '): \'keyboardSupport\' option must be a boolean.'); } function M(t, e) { t.documentElement = e; } function O(t, e) { if (typeof e !== 'string' && !1 !== e) throw new Error('noUiSlider (' + ut + '): \'cssPrefix\' must be a string or `false`.'); t.cssPrefix = e; } function L(t, e) { if (typeof e !== 'object') throw new Error('noUiSlider (' + ut + '): \'cssClasses\' must be an object.'); if (typeof t.cssPrefix === 'string') for (const r in t.cssClasses = {}, e)e.hasOwnProperty(r) && (t.cssClasses[r] = t.cssPrefix + e[r]); else t.cssClasses = e; } function bt(e) { const r = { margin: 0, limit: 0, padding: 0, animate: !0, animationDuration: 300, ariaFormat: u, format: u }; const n = { step: { r: !1, t: h }, start: { r: !0, t: g }, connect: { r: !0, t: x }, direction: { r: !0, t: N }, snap: { r: !1, t: v }, animate: { r: !1, t: b }, animationDuration: { r: !1, t: S }, range: { r: !0, t: m }, orientation: { r: !1, t: w }, margin: { r: !1, t: y }, limit: { r: !1, t: E }, padding: { r: !1, t: C }, behaviour: { r: !0, t: U }, ariaFormat: { r: !1, t: P }, format: { r: !1, t: A }, tooltips: { r: !1, t: k }, keyboardSupport: { r: !0, t: V }, documentElement: { r: !1, t: M }, cssPrefix: { r: !0, t: O }, cssClasses: { r: !0, t: L } }; const i = { connect: !1, direction: 'ltr', behaviour: 'tap', orientation: 'horizontal', keyboardSupport: !0, cssPrefix: 'noUi-', cssClasses: { target: 'target', base: 'base', origin: 'origin', handle: 'handle', handleLower: 'handle-lower', handleUpper: 'handle-upper', touchArea: 'touch-area', horizontal: 'horizontal', vertical: 'vertical', background: 'background', connect: 'connect', connects: 'connects', ltr: 'ltr', rtl: 'rtl', draggable: 'draggable', drag: 'state-drag', tap: 'state-tap', active: 'active', tooltip: 'tooltip', pips: 'pips', pipsHorizontal: 'pips-horizontal', pipsVertical: 'pips-vertical', marker: 'marker', markerHorizontal: 'marker-horizontal', markerVertical: 'marker-vertical', markerNormal: 'marker-normal', markerLarge: 'marker-large', markerSub: 'marker-sub', value: 'value', valueHorizontal: 'value-horizontal', valueVertical: 'value-vertical', valueNormal: 'value-normal', valueLarge: 'value-large', valueSub: 'value-sub' } }; e.format && !e.ariaFormat && (e.ariaFormat = e.format), Object.keys(n).forEach((t) => { if (!s(e[t]) && void 0 === i[t]) { if (n[t].r) throw new Error('noUiSlider (' + ut + '): \'' + t + '\' is required.'); return !0; }n[t].t(r, s(e[t]) ? e[t] : i[t]); }), r.pips = e.pips; const t = document.createElement('div'); const o = void 0 !== t.style.msTransform; const a = void 0 !== t.style.transform; r.transformRule = a ? 'transform' : o ? 'msTransform' : 'webkitTransform'; return r.style = [['left', 'top'], ['right', 'bottom']][r.dir][r.ort], r; } function z(t, f, o) { let l; let u; let a; let c; let i; let s; let e; let p; const d = window.navigator.pointerEnabled ? { start: 'pointerdown', move: 'pointermove', end: 'pointerup' } : window.navigator.msPointerEnabled ? { start: 'MSPointerDown', move: 'MSPointerMove', end: 'MSPointerUp' } : { start: 'mousedown touchstart', move: 'mousemove touchmove', end: 'mouseup touchend' }; const h = window.CSS && CSS.supports && CSS.supports('touch-action', 'none') && (function () { let t = !1; try { const e = Object.defineProperty({}, 'passive', { get() { t = !0; } }); window.addEventListener('test', null, e); } catch (t) {} return t; }()); const y = t; let E = f.spectrum; const m = []; let g = []; const v = []; let b = 0; const S = {}; const x = t.ownerDocument; const w = f.documentElement || x.documentElement; const C = x.body; const N = -1; const U = 0; const k = 1; const P = 2; const A = x.dir === 'rtl' || f.ort === 1 ? 0 : 100; function V(t, e) { const r = x.createElement('div'); return e && mt(r, e), t.appendChild(r), r; } function M(t, e) { const r = V(t, f.cssClasses.origin); const n = V(r, f.cssClasses.handle); return V(n, f.cssClasses.touchArea), n.setAttribute('data-handle', e), f.keyboardSupport && (n.setAttribute('tabindex', '0'), n.addEventListener('keydown', (t) => { return (function (t, e) { if (L() || z(e)) return !1; const r = ['Left', 'Right']; const n = ['Down', 'Up']; f.dir && !f.ort ? r.reverse() : f.ort && !f.dir && n.reverse(); const i = t.key.replace('Arrow', ''); const o = i === n[0] || i === r[0]; const a = i === n[1] || i === r[1]; if (!o && !a) return !0; t.preventDefault(); const s = o ? 0 : 1; let l = lt(e)[s]; if (l === null) return !1; !1 === l && (l = E.getDefaultStep(g[e], o, 10)); return l = Math.max(l, 1e-7), l *= o ? -1 : 1, at(e, m[e] + l, !0), !1; }(t, e)); })), n.setAttribute('role', 'slider'), n.setAttribute('aria-orientation', f.ort ? 'vertical' : 'horizontal'), e === 0 ? mt(n, f.cssClasses.handleLower) : e === f.handles - 1 && mt(n, f.cssClasses.handleUpper), r; } function O(t, e) { return !!e && V(t, f.cssClasses.connect); } function r(t, e) { return !!f.tooltips[e] && V(t.firstChild, f.cssClasses.tooltip); } function L() { return y.hasAttribute('disabled'); } function z(t) { return u[t].hasAttribute('disabled'); } function j() { i && (G('update.tooltips'), i.forEach((t) => { t && ct(t); }), i = null); } function H() { j(), i = u.map(r), $('update.tooltips', (t, e, r) => { if (i[e]) { let n = t[e]; !0 !== f.tooltips[e] && (n = f.tooltips[e].to(r[e])), i[e].innerHTML = n; } }); } function F(e, i, o) { const a = x.createElement('div'); const s = []; s[U] = f.cssClasses.valueNormal, s[k] = f.cssClasses.valueLarge, s[P] = f.cssClasses.valueSub; const l = []; l[U] = f.cssClasses.markerNormal, l[k] = f.cssClasses.markerLarge, l[P] = f.cssClasses.markerSub; const u = [f.cssClasses.valueHorizontal, f.cssClasses.valueVertical]; const c = [f.cssClasses.markerHorizontal, f.cssClasses.markerVertical]; function p(t, e) { const r = e === f.cssClasses.value; const n = r ? s : l; return e + ' ' + (r ? u : c)[f.ort] + ' ' + n[t]; } return mt(a, f.cssClasses.pips), mt(a, f.ort === 0 ? f.cssClasses.pipsHorizontal : f.cssClasses.pipsVertical), Object.keys(e).forEach((t) => { !(function (t, e, r) { if ((r = i ? i(e, r) : r) !== N) { let n = V(a, !1); n.className = p(r, f.cssClasses.marker), n.style[f.style] = t + '%', U < r && ((n = V(a, !1)).className = p(r, f.cssClasses.value), n.setAttribute('data-value', e), n.style[f.style] = t + '%', n.innerHTML = o.to(e)); } }(t, e[t][0], e[t][1])); }), a; } function D() { c && (ct(c), c = null); } function T(t) { D(); let m; let g; let v; let b; let e; let r; let S; let x; let w; const n = t.mode; const i = t.density || 1; const o = t.filter || !1; const a = (function (t, e, r) { if (t === 'range' || t === 'steps') return E.xVal; if (t === 'count') { if (e < 2) throw new Error('noUiSlider (' + ut + '): \'values\' (>= 2) required for mode \'count\'.'); let n = e - 1; const i = 100 / n; for (e = []; n--;)e[n] = n * i; e.push(100), t = 'positions'; } return t === 'positions' ? e.map((t) => { return E.fromStepping(r ? E.getStep(t) : t); }) : t === 'values' ? r ? e.map((t) => { return E.fromStepping(E.getStep(E.toStepping(t))); }) : e : void 0; }(n, t.values || !1, t.stepped || !1)); const s = (m = i, g = n, v = a, b = {}, e = E.xVal[0], r = E.xVal[E.xVal.length - 1], x = S = !1, w = 0, (v = v.slice().sort((t, e) => { return t - e; }).filter(function (t) { return !this[t] && (this[t] = !0); }, {}))[0] !== e && (v.unshift(e), S = !0), v[v.length - 1] !== r && (v.push(r), x = !0), v.forEach((t, e) => { let r; let n; let i; let o; let a; let s; let l; let u; let c; let p; const f = t; const d = v[e + 1]; const h = g === 'steps'; if (h && (r = E.xNumSteps[e]), r || (r = d - f), !1 !== f && void 0 !== d) for (r = Math.max(r, 1e-7), n = f; n <= d; n = (n + r).toFixed(7) / 1) { for (u = (a = (o = E.toStepping(n)) - w) / m, p = a / (c = Math.round(u)), i = 1; i <= c; i += 1)b[(s = w + i * p).toFixed(5)] = [E.fromStepping(s), 0]; l = v.indexOf(n) > -1 ? k : h ? P : U, !e && S && (l = 0), n === d && x || (b[o.toFixed(5)] = [n, l]), w = o; } }), b); const l = t.format || { to: Math.round }; return c = y.appendChild(F(s, o, l)); } function R() { const t = l.getBoundingClientRect(); const e = 'offset' + ['Width', 'Height'][f.ort]; return f.ort === 0 ? t.width || l[e] : t.height || l[e]; } function B(n, i, o, a) { const e = function (t) { return !!(t = (function (t, e, r) { let n; let i; const o = t.type.indexOf('touch') === 0; const a = t.type.indexOf('mouse') === 0; let s = t.type.indexOf('pointer') === 0; t.type.indexOf('MSPointer') === 0 && (s = !0); if (o) { const l = function (t) { return t.target === r || r.contains(t.target); }; if (t.type === 'touchstart') { const u = Array.prototype.filter.call(t.touches, l); if (u.length > 1) return !1; n = u[0].pageX, i = u[0].pageY; } else { const c = Array.prototype.find.call(t.changedTouches, l); if (!c) return !1; n = c.pageX, i = c.pageY; } }e = e || vt(x), (a || s) && (n = t.clientX + e.x, i = t.clientY + e.y); return t.pageOffset = e, t.points = [n, i], t.cursor = a || s, t; }(t, a.pageOffset, a.target || i))) && (!(L() && !a.doNotReject) && (e = y, r = f.cssClasses.tap, !((e.classList ? e.classList.contains(r) : new RegExp('\\b' + r + '\\b').test(e.className)) && !a.doNotReject) && (!(n === d.start && void 0 !== t.buttons && t.buttons > 1) && ((!a.hover || !t.buttons) && (h || t.preventDefault(), t.calcPoint = t.points[f.ort], void o(t, a)))))); let e; let r; }; const r = []; return n.split(' ').forEach((t) => { i.addEventListener(t, e, !!h && { passive: !0 }), r.push([t, e]); }), r; } function q(t) { let e; let r; let n; let i; let o; let a; let s = 100 * (t - (e = l, r = f.ort, n = e.getBoundingClientRect(), i = e.ownerDocument, o = i.documentElement, a = vt(i), /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (a.x = 0), r ? n.top + a.y - o.clientTop : n.left + a.x - o.clientLeft)) / R(); return s = dt(s), f.dir ? 100 - s : s; } function X(t, e) { t.type === 'mouseout' && t.target.nodeName === 'HTML' && t.relatedTarget === null && _(t, e); } function Y(t, e) { if (navigator.appVersion.indexOf('MSIE 9') === -1 && t.buttons === 0 && e.buttonsProperty !== 0) return _(t, e); const r = (f.dir ? -1 : 1) * (t.calcPoint - e.startCalcPoint); Z(r > 0, 100 * r / e.baseSize, e.locations, e.handleNumbers); } function _(t, e) { e.handle && (gt(e.handle, f.cssClasses.active), b -= 1), e.listeners.forEach((t) => { w.removeEventListener(t[0], t[1]); }), b === 0 && (gt(y, f.cssClasses.drag), et(), t.cursor && (C.style.cursor = '', C.removeEventListener('selectstart', pt))), e.handleNumbers.forEach((t) => { J('change', t), J('set', t), J('end', t); }); } function I(t, e) { if (e.handleNumbers.some(z)) return !1; let r; e.handleNumbers.length === 1 && (r = u[e.handleNumbers[0]].children[0], b += 1, mt(r, f.cssClasses.active)); t.stopPropagation(); const n = []; const i = B(d.move, w, Y, { target: t.target, handle: r, listeners: n, startCalcPoint: t.calcPoint, baseSize: R(), pageOffset: t.pageOffset, handleNumbers: e.handleNumbers, buttonsProperty: t.buttons, locations: g.slice() }); const o = B(d.end, w, _, { target: t.target, handle: r, listeners: n, doNotReject: !0, handleNumbers: e.handleNumbers }); const a = B('mouseout', w, X, { target: t.target, handle: r, listeners: n, doNotReject: !0, handleNumbers: e.handleNumbers }); n.push.apply(n, i.concat(o, a)), t.cursor && (C.style.cursor = getComputedStyle(t.target).cursor, u.length > 1 && mt(y, f.cssClasses.drag), C.addEventListener('selectstart', pt, !1)), e.handleNumbers.forEach((t) => { J('start', t); }); } function n(t) { t.stopPropagation(); let n; let i; let o; const e = q(t.calcPoint); const r = (n = e, o = !(i = 100), u.forEach((t, e) => { if (!z(e)) { const r = Math.abs(g[e] - n); (r < i || r === 100 && i === 100) && (o = e, i = r); } }), o); if (!1 === r) return !1; f.events.snap || ft(y, f.cssClasses.tap, f.animationDuration), rt(r, e, !0, !0), et(), J('slide', r, !0), J('update', r, !0), J('change', r, !0), J('set', r, !0), f.events.snap && I(t, { handleNumbers: [r] }); } function W(t) { const e = q(t.calcPoint); const r = E.getStep(e); const n = E.fromStepping(r); Object.keys(S).forEach((t) => { t.split('.')[0] === 'hover' && S[t].forEach((t) => { t.call(s, n); }); }); } function $(t, e) { S[t] = S[t] || [], S[t].push(e), t.split('.')[0] === 'update' && u.forEach((t, e) => { J('update', e); }); } function G(t) { const n = t && t.split('.')[0]; const i = n && t.substring(n.length); Object.keys(S).forEach((t) => { const e = t.split('.')[0]; const r = t.substring(e.length); n && n !== e || i && i !== r || delete S[t]; }); } function J(r, n, i) { Object.keys(S).forEach((t) => { const e = t.split('.')[0]; r === e && S[t].forEach((t) => { t.call(s, m.map(f.format.to), n, m.slice(), i || !1, g.slice()); }); }); } function K(t, e, r, n, i, o) { return u.length > 1 && !f.events.unconstrained && (n && e > 0 && (r = Math.max(r, t[e - 1] + f.margin)), i && e < u.length - 1 && (r = Math.min(r, t[e + 1] - f.margin))), u.length > 1 && f.limit && (n && e > 0 && (r = Math.min(r, t[e - 1] + f.limit)), i && e < u.length - 1 && (r = Math.max(r, t[e + 1] - f.limit))), f.padding && (e === 0 && (r = Math.max(r, f.padding[0])), e === u.length - 1 && (r = Math.min(r, 100 - f.padding[1]))), !((r = dt(r = E.getStep(r))) === t[e] && !o) && r; } function Q(t, e) { const r = f.ort; return (r ? e : t) + ', ' + (r ? t : e); } function Z(t, n, r, e) { const i = r.slice(); let o = [!t, t]; let a = [t, !t]; e = e.slice(), t && e.reverse(), e.length > 1 ? e.forEach((t, e) => { const r = K(i, t, i[t] + n, o[e], a[e], !1); !1 === r ? n = 0 : (n = r - i[t], i[t] = r); }) : o = a = [!0]; let s = !1; e.forEach((t, e) => { s = rt(t, r[t] + n, o[e], a[e]) || s; }), s && e.forEach((t) => { J('update', t), J('slide', t); }); } function tt(t, e) { return f.dir ? 100 - t - e : t; } function et() { v.forEach((t) => { const e = g[t] > 50 ? -1 : 1; const r = 3 + (u.length + e * t); u[t].style.zIndex = r; }); } function rt(t, e, r, n) { return !1 !== (e = K(g, t, e, r, n, !1)) && ((function (t, e) { g[t] = e, m[t] = E.fromStepping(e); const r = 'translate(' + Q(tt(e, 0) - A + '%', '0') + ')'; u[t].style[f.transformRule] = r, nt(t), nt(t + 1); }(t, e)), !0); } function nt(t) { if (a[t]) { let e = 0; let r = 100; t !== 0 && (e = g[t - 1]), t !== a.length - 1 && (r = g[t]); const n = r - e; const i = 'translate(' + Q(tt(e, n) + '%', '0') + ')'; const o = 'scale(' + Q(n / 100, '1') + ')'; a[t].style[f.transformRule] = i + ' ' + o; } } function it(t, e) { return t === null || !1 === t || void 0 === t ? g[e] : (typeof t === 'number' && (t = String(t)), t = f.format.from(t), !1 === (t = E.toStepping(t)) || isNaN(t) ? g[e] : t); } function ot(t, e) { const r = ht(t); const n = void 0 === g[0]; e = void 0 === e || !!e, f.animate && !n && ft(y, f.cssClasses.tap, f.animationDuration), v.forEach((t) => { rt(t, it(r[t], t), !0, !1); }), v.forEach((t) => { rt(t, g[t], !0, !0); }), et(), v.forEach((t) => { J('update', t), r[t] !== null && e && J('set', t); }); } function at(t, e, r) { if (!((t = Number(t)) >= 0 && t < v.length)) throw new Error('noUiSlider (' + ut + '): invalid handle number, got: ' + t); rt(t, it(e, t), !0, !0), J('update', t), r && J('set', t); } function st() { const t = m.map(f.format.to); return t.length === 1 ? t[0] : t; } function lt(t) { const e = g[t]; const r = E.getNearbySteps(e); const n = m[t]; let i = r.thisStep.step; let o = null; if (f.snap) return [n - r.stepBefore.startValue || null, r.stepAfter.startValue - n || null]; !1 !== i && n + i > r.stepAfter.startValue && (i = r.stepAfter.startValue - n), o = n > r.thisStep.startValue ? r.thisStep.step : !1 !== r.stepBefore.step && n - r.stepBefore.highestStep, e === 100 ? i = null : e === 0 && (o = null); const a = E.countStepDecimals(); return i !== null && !1 !== i && (i = Number(i.toFixed(a))), o !== null && !1 !== o && (o = Number(o.toFixed(a))), [o, i]; } return mt(e = y, f.cssClasses.target), f.dir === 0 ? mt(e, f.cssClasses.ltr) : mt(e, f.cssClasses.rtl), f.ort === 0 ? mt(e, f.cssClasses.horizontal) : mt(e, f.cssClasses.vertical), l = V(e, f.cssClasses.base), (function (t, e) { const r = V(e, f.cssClasses.connects); u = [], (a = []).push(O(r, t[0])); for (let n = 0; n < f.handles; n++)u.push(M(e, n)), v[n] = n, a.push(O(r, t[n + 1])); }(f.connect, l)), (p = f.events).fixed || u.forEach((t, e) => { B(d.start, t.children[0], I, { handleNumbers: [e] }); }), p.tap && B(d.start, l, n, {}), p.hover && B(d.move, l, W, { hover: !0 }), p.drag && a.forEach((t, e) => { if (!1 !== t && e !== 0 && e !== a.length - 1) { const r = u[e - 1]; const n = u[e]; const i = [t]; mt(t, f.cssClasses.draggable), p.fixed && (i.push(r.children[0]), i.push(n.children[0])), i.forEach((t) => { B(d.start, t, I, { handles: [r, n], handleNumbers: [e - 1, e] }); }); } }), ot(f.start), f.pips && T(f.pips), f.tooltips && H(), $('update', (t, e, a, r, s) => { v.forEach((t) => { const e = u[t]; let r = K(g, t, 0, !0, !0, !0); let n = K(g, t, 100, !0, !0, !0); let i = s[t]; const o = f.ariaFormat.to(a[t]); r = E.fromStepping(r).toFixed(1), n = E.fromStepping(n).toFixed(1), i = E.fromStepping(i).toFixed(1), e.children[0].setAttribute('aria-valuemin', r), e.children[0].setAttribute('aria-valuemax', n), e.children[0].setAttribute('aria-valuenow', i), e.children[0].setAttribute('aria-valuetext', o); }); }), s = { destroy() { for (const t in f.cssClasses)f.cssClasses.hasOwnProperty(t) && gt(y, f.cssClasses[t]); for (;y.firstChild;)y.removeChild(y.firstChild); delete y.noUiSlider; }, steps() { return v.map(lt); }, on: $, off: G, get: st, set: ot, setHandle: at, reset(t) { ot(f.start, t); }, __moveHandles(t, e, r) { Z(t, e, g, r); }, options: o, updateOptions(e, t) { const r = st(); const n = ['margin', 'limit', 'padding', 'range', 'animate', 'snap', 'step', 'format', 'pips', 'tooltips']; n.forEach((t) => { void 0 !== e[t] && (o[t] = e[t]); }); const i = bt(o); n.forEach((t) => { void 0 !== e[t] && (f[t] = i[t]); }), E = i.spectrum, f.margin = i.margin, f.limit = i.limit, f.padding = i.padding, f.pips ? T(f.pips) : D(), f.tooltips ? H() : j(), g = [], ot(e.start || r, t); }, target: y, removePips: D, removeTooltips: j, pips: T }; } return { __spectrum: l, version: ut, create(t, e) { if (!t || !t.nodeName) throw new Error('noUiSlider (' + ut + '): create requires a single element, got: ' + t); if (t.noUiSlider) throw new Error('noUiSlider (' + ut + '): Slider was already initialized.'); const r = z(t, bt(e), e); return t.noUiSlider = r; } };
}));
